{
  "version": 3,
  "file": "spec.js",
  "sources": [
    "spec/helpers/helper.js",
    "spec/helpers/jasmine-given.js",
    "spec/helpers/jasmine.async.js",
    "generated/js/spec.coffee.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA,+B;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "var root = this;\n\nroot.context = root.describe;\nroot.xcontext = root.xdescribe;",
    "/* jasmine-given - 2.3.0\n * Adds a Given-When-Then DSL to jasmine as an alternative style for specs\n * https://github.com/searls/jasmine-given\n */\n(function() {\n  (function(jasmine) {\n    var declareJasmineSpec, doneWrapperFor, getBlock, invariantList, mostRecentExpectations, mostRecentlyUsed, o, root, stringifyExpectation, whenList;\n    mostRecentlyUsed = null;\n    stringifyExpectation = function(expectation) {\n      var matches;\n      matches = expectation.toString().replace(/\\n/g, '').match(/function\\s?\\(.*\\)\\s?{\\s*(return\\s+)?(.*?)(;)?\\s*}/i);\n      if (matches && matches.length >= 3) {\n        return matches[2].replace(/\\s+/g, ' ');\n      } else {\n        return \"\";\n      }\n    };\n    beforeEach(function() {\n      return this.addMatchers({\n        toHaveReturnedFalseFromThen: function(context, n, done) {\n          var e, exception, result;\n          result = false;\n          exception = void 0;\n          try {\n            result = this.actual.call(context, done);\n          } catch (_error) {\n            e = _error;\n            exception = e;\n          }\n          this.message = function() {\n            var msg;\n            msg = \"Then clause \" + (n > 1 ? \" #\" + n : \"\") + \" `\" + (stringifyExpectation(this.actual)) + \"` failed by \";\n            if (exception) {\n              msg += \"throwing: \" + exception.toString();\n            } else {\n              msg += \"returning false\";\n            }\n            return msg;\n          };\n          return result === false;\n        }\n      });\n    });\n    root = this;\n    root.Given = function() {\n      mostRecentlyUsed = root.Given;\n      return beforeEach(getBlock(arguments));\n    };\n    whenList = [];\n    root.When = function() {\n      var b;\n      mostRecentlyUsed = root.When;\n      b = getBlock(arguments);\n      beforeEach(function() {\n        return whenList.push(b);\n      });\n      return afterEach(function() {\n        return whenList.pop();\n      });\n    };\n    invariantList = [];\n    root.Invariant = function(invariantBehavior) {\n      mostRecentlyUsed = root.Invariant;\n      beforeEach(function() {\n        return invariantList.push(invariantBehavior);\n      });\n      return afterEach(function() {\n        return invariantList.pop();\n      });\n    };\n    getBlock = function(thing) {\n      var assignResultTo, setupFunction;\n      setupFunction = o(thing).firstThat(function(arg) {\n        return o(arg).isFunction();\n      });\n      assignResultTo = o(thing).firstThat(function(arg) {\n        return o(arg).isString();\n      });\n      return doneWrapperFor(setupFunction, function(done) {\n        var context, result;\n        context = jasmine.getEnv().currentSpec;\n        result = setupFunction.call(context, done);\n        if (assignResultTo) {\n          if (!context[assignResultTo]) {\n            return context[assignResultTo] = result;\n          } else {\n            throw new Error(\"Unfortunately, the variable '\" + assignResultTo + \"' is already assigned to: \" + context[assignResultTo]);\n          }\n        }\n      });\n    };\n    mostRecentExpectations = null;\n    declareJasmineSpec = function(specArgs, itFunction) {\n      var expectationFunction, expectations, label;\n      if (itFunction == null) {\n        itFunction = it;\n      }\n      label = o(specArgs).firstThat(function(arg) {\n        return o(arg).isString();\n      });\n      expectationFunction = o(specArgs).firstThat(function(arg) {\n        return o(arg).isFunction();\n      });\n      mostRecentlyUsed = root.subsequentThen;\n      mostRecentExpectations = expectations = [expectationFunction];\n      itFunction(\"then \" + (label != null ? label : stringifyExpectation(expectations)), doneWrapperFor(expectationFunction, function(done) {\n        var block, expectation, i, _i, _j, _len, _len1, _ref, _ref1, _results;\n        _ref = whenList != null ? whenList : [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          block = _ref[_i];\n          block();\n        }\n        _ref1 = invariantList.concat(expectations);\n        _results = [];\n        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {\n          expectation = _ref1[i];\n          _results.push(expect(expectation).not.toHaveReturnedFalseFromThen(jasmine.getEnv().currentSpec, i + 1, done));\n        }\n        return _results;\n      }));\n      return {\n        Then: subsequentThen,\n        And: subsequentThen\n      };\n    };\n    doneWrapperFor = function(func, toWrap) {\n      if (func.length === 0) {\n        return function() {\n          return toWrap();\n        };\n      } else {\n        return function(done) {\n          return toWrap(done);\n        };\n      }\n    };\n    root.Then = function() {\n      return declareJasmineSpec(arguments);\n    };\n    root.Then.only = function() {\n      return declareJasmineSpec(arguments, it.only);\n    };\n    root.subsequentThen = function(additionalExpectation) {\n      mostRecentExpectations.push(additionalExpectation);\n      return this;\n    };\n    mostRecentlyUsed = root.Given;\n    root.And = function() {\n      return mostRecentlyUsed.apply(this, jasmine.util.argsToArray(arguments));\n    };\n    return o = function(thing) {\n      return {\n        isFunction: function() {\n          return Object.prototype.toString.call(thing) === \"[object Function]\";\n        },\n        isString: function() {\n          return Object.prototype.toString.call(thing) === \"[object String]\";\n        },\n        firstThat: function(test) {\n          var i;\n          i = 0;\n          while (i < thing.length) {\n            if (test(thing[i]) === true) {\n              return thing[i];\n            }\n            i++;\n          }\n          return void 0;\n        }\n      };\n    };\n  })(jasmine);\n\n}).call(this);\n",
    "// Jasmine.Async, v0.1.0\n// Copyright (c)2012 Muted Solutions, LLC. All Rights Reserved.\n// Distributed under MIT license\n// http://github.com/derickbailey/jasmine.async\nthis.AsyncSpec = (function(global){\n\n  // Private Methods\n  // ---------------\n  \n  function runAsync(block){\n    return function(){\n      var done = false;\n      var complete = function(){ done = true; };\n\n      runs(function(){\n        block(complete);\n      });\n\n      waitsFor(function(){\n        return done;\n      });\n    };\n  }\n\n  // Constructor Function\n  // --------------------\n\n  function AsyncSpec(spec){\n    this.spec = spec;\n  }\n\n  // Public API\n  // ----------\n\n  AsyncSpec.prototype.beforeEach = function(block){\n    this.spec.beforeEach(runAsync(block));\n  };\n\n  AsyncSpec.prototype.afterEach = function(block){\n    this.spec.afterEach(runAsync(block));\n  };\n\n  AsyncSpec.prototype.it = function(description, block){\n    // For some reason, `it` is not attached to the current\n    // test suite, so it has to be called from the global\n    // context.\n    global.it(description, runAsync(block));\n  };\n\n  return AsyncSpec;\n})(this);",
    "(function() {\n  describe('jasmine-before-all', function() {\n    describe('intentional pollution', function() {\n      var foo;\n      foo = 0;\n      beforeAll(function() {\n        return foo += 1;\n      });\n      context('1', function() {\n        return Then(function() {\n          return foo === 1;\n        });\n      });\n      context('2', function() {\n        return Then(function() {\n          return foo === 1;\n        });\n      });\n      context('3', function() {\n        return Then(function() {\n          return foo === 1;\n        });\n      });\n      return afterAll(function() {\n        foo++;\n        return expect(foo).toEqual(2);\n      });\n    });\n    return describe(\"exploding occurring when afterAll is called twice\", function() {\n      var callCount;\n      callCount = 0;\n      afterAll(function() {\n        callCount++;\n        return expect(callCount).toEqual(1);\n      });\n      Then(function() {\n        return true;\n      });\n      Then(function() {\n        return true;\n      });\n      return describe(\"foo\", function() {\n        Then(function() {\n          return true;\n        });\n        return Then(function() {\n          return true;\n        });\n      });\n    });\n  });\n\n}).call(this);\n"
  ]
}